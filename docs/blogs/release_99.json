{
  "Title": "Memory Management: Introduction to Weak References in JavaScript",
  "Slug": "memory-management-introduction-to-how-weak-references-work-in-javascript",
  "Collection ID": "642da2c43fe34c364a69857f",
  "Item ID": "642da2c43fe34cd764698aa0",
  "Created On": "Fri Jan 06 2023 16:31:09 GMT+0000 (Coordinated Universal Time)",
  "Updated On": "Wed Mar 29 2023 18:32:30 GMT+0000 (Coordinated Universal Time)",
  "PublishedOn": "Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)",
  "MainImage": "https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd51eabe2fe821ce24c333_weakmapandweakset_1a134e00646265ea279ee480f2ea7ebd_2000.jpeg",
  "Post summary": "The concept of weak references is relatively new in JavaScript. WeakSet and WeakMap are data structures introduced in JavaScript ES6; let's talk about them.",
  "FullPost": "<p>The management of the memory used during a program&#x27;s execution determines the program&#x27;s optimal performance. Therefore, this aspect of programming needs attention from software developers.</p><p>The garbage collector, a browser process that runs in the background in the JavaScript engine, helps to monitor the allocation of memory and determine when allocated memory is no longer needed, and then reclaims it. When declaring objects, references to these objects are strongly held. Therefore, these objects won’t be garbage-collected as long as their references still exist.</p><p>The concept of weak references is relatively new in JavaScript. <code>WeakSet</code> and <code>WeakMap</code> are data structures introduced in JavaScript ES6, and are the prospective approach to weakly reference an object in JavaScript. However, in a JavaScript program, using an object as a field/key to a <code>WeakMap</code> or <code>WeakSet</code> won&#x27;t prevent it from being garbage-collected.</p><p>In this tutorial, we&#x27;ll learn about weak references concerning <code>WeakSet</code> and <code>WeakMap</code> in JavaScript and how to utilize them for performance. First, let&#x27;s quickly understand JavaScript garbage collection before later exploring <code>WeakSet</code> and <code>WeakMap</code> data structures.</p><h2 id=\"ahvni\">A Quick Intro to Garbage Collection in JavaScript</h2><p>Garbage collection refers to the cleaning of memory when objects or variables stored in that space are no longer in use. Memory management is important while writing JavaScript, as with every programming language. JavaScript, unlike C, is a high-level programming language designed to automatically clear memory when objects are no longer needed. While garbage collection is a complex issue, it is critical to grasp it when addressing references. Read more about memory management through garbage collection <u><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#:~:text=Some%20high-level%20languages%2C%20such,longer%20needed%20and%20reclaim%20it.\" target=\"_blank\" rel=\"noopener noreferrer\">here</a></u>.</p><p>The JavaScript engine controls the automated garage collecting procedure. When a value is accessible, it is guaranteed to be retained in memory and not garbage collected. A value can be reachable in two ways: First, a value is part of the base set of values that can be reached from the global variables. The function is being executed from its local variables. The alternative method is to access any value from the root via a reference or chain of references. Let’s assume we establish an item in a global variable; this object is reachable via the global space, and so it is deemed reachable.</p><h2 id=\"9kluq\">Understanding Weak References in JavaScript</h2><p>Let’s talk briefly about how <strong>weak references</strong> and <strong>strong references</strong> work so we can better understand how the <code>WeakMap</code> and <code>WeakSet</code> work. A weak reference is a reference to an object, the sole reference to the object in memory, and does not prohibit garbage collection.</p><p>Let’s apply this idea to the preceding example of a strong reference, and then apply it in setting a weak reference. We’ll ignore the usage of <code>WeakMap</code> for the time being, as we’ll cover it in greater detail later. For now, consider the following examples of weak reference behavior:</p><pre>let company = new WeakMap();<br>let company = { name: &#x27;microsoft&#x27; };<br><br>company.set(microsoft, &#x27;correct&#x27;);<br>console.log(company);<br><br>microsoft = null;<br>console.log(company); // microsoft doesn’t exist again because it has been garbage collected.</pre><p>In a strong reference, the reference to the original <code>microsoft</code> object will remain, while the <code>microsoft</code> object stays in the <code>WeakMap</code> and may be accessed without difficulty.</p><p>However, when we rename the variable to null and replace the reference with the original <code>microsoft</code> object, the original object in memory contains the weak reference back to the <code>WeakMap</code> that we constructed.</p><p>This implies that the <code>microsoft</code> object will be deleted from memory, and we’ll assign the <code>WeakMap</code> to the next time the JavaScript engine performs a garbage collection procedure.</p><p>The main distinction between strong and weak references is that a strong reference prevents an item from being garbage collected, but a weak reference does not.</p><p>JavaScript employs strong references by default for all of its references, and the only method for using weak references is with a <code>WeakMap</code> or a <code>WeakSet</code>. While a strong reference would prohibit the garbage collection of an item even if it were the sole object accessing it, a weak reference would not. Let’s see this in the example below:</p><pre>let company = { name: &#x27;microsoft&#x27; };<br><br>const company = [microsoft];<br><br>microsoft = null;<br>console.log(company); // [{ name: &#x27;microsoft&#x27; }]</pre><p>We can insert the object into an array and delete the reference to the original object by changing its value to null through generating it as an object.</p><p>Although we can no longer access the object via the <code>microsoft</code> variable due to a strong reference between the <code>company</code> array and the object, the object is still preserved in memory. It can be accessed via <code>company[0]</code>.</p><p>In other words, the strong reference prevents the item from being removed from memory via garbage collection.</p><h2 id=\"a1v3k\">The Difference Between Map and WeakMap</h2><p>As we learned about garbage collection, the JavaScript engine stores a value in memory for as long as it is accessible. Let&#x27;s look at some examples:</p><pre>let tesla = { name: &#x27;car&#x27; };<br><br>tesla = null;<br>// The object is not functional again.</pre><p>While a data structure is in memory, its properties are considered accessible, so they’re typically preserved. If we store an item in an array, the object may still be retrieved even if it has no other references, as long as the array is in memory.</p><pre>let map = new Map();<br><br>let tesla = { name: &#x27;car&#x27; };<br><br>map.set(tesla, &#x27;car&#x27;);<br><br>// Overwrite the reference.<br>tesla = null;<br><br>// To access the object.<br>console.log(map.keys());</pre><p>The <code>Map</code> object keeps track of key-value pairs and remembers the order in which they were added. Any value (objects and primitive values alike) can be used as a key or a value.</p><p>This means the object is similar to an object in that we can store key-value pairs and retrieve the values within the <code>Map</code> using the key. However, unlike a typical JavaScript object, we must use the <code>.get()</code> function to get the values.</p><p>A <code>WeakMap</code> is quite similar to a <code>Map</code>, except the references it stores are weak references, which means it will not prevent garbage collection from deleting items it refers to if they are not firmly linked elsewhere.</p><p><code>WeakMap</code> also has the disadvantage of not being enumerable, due to the weak references.</p><p>Finally, we must use objects as keys, but the values can be anything, such as text or an integer. Here is an example of  a <code>WeakMap</code> and the techniques that can be applied to it:</p><pre>const countries = new WeakMap();<br>const continents = new WeakMap();<br>const obj1 = {};<br>const obj2 = window;<br><br>countries.set(obj1, &#x27;italy&#x27;);<br>countries.set(obj2, &#x27;USA&#x27;);<br><br>// The value can be set to anything<br><br>countries.set(countries, continents); // a WeakMap<br>continents.set(obj1, obj2);  // a variable<br>countries.get(obj1); // italy<br><br>countries.has(obj1); // true<br>countries.delete(obj1);<br>countries.has(obj1); // false, this is because the object has been deleted<br>console.log(countries);</pre><p><code>WeakMap()</code> can also be used to store additional data. Let’s assume we&#x27;re developing a food delivery app platform with software that counts the number of people who use the application. In this scenario, we&#x27;d like to reduce the count when customers leave. This task would be difficult to accomplish with <code>Map</code>, but it’s relatively simple with <code>WeakMap()</code>:</p><pre>let countPerson = new WeakMap();<br>function countUsers(user) {<br> let count = countPerson.get(user)<br>  countPerson.set(user, count ++);<br>}<br><br>let person = { name: &#x27;Jordan&#x27; };<br><br>// Taking count of person<br>countUsers(person);<br><br>// person leaves<br>person = null;</pre><p>When using <code>Map()</code>, we must clean <code>countPerson</code> every time a client leaves; otherwise, it would take up space by continually increasing memory. However, by using <code>WeakMap()</code>, we do not need to do this cleaning step; it is automatically garbage-collected.</p><h2 id=\"b1ku3\">The Difference Between Set and WeakSet</h2><p>The <code>Set</code> object allows us to store unique values of any type, whether they’re raw values or object references. A set, like an array, lacks a key-value pair. Using array methods <code>for...of</code> and <code>.forEach()</code>, we can iterate through a set of arrays:</p><pre>let meals = new Set([&#x27;Rice&#x27;, &#x27;Pizza&#x27;, &#x27;Risotto&#x27;, &#x27;Garri&#x27;]);<br>for (let names of meals) {<br> console.log(names);<br>} // Rice, Pizza, Risotto, Garri</pre><p><u><code><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet\" target=\"_blank\" rel=\"noopener noreferrer\">WeakSet</a></code></u> objects are object collections. Like <code>Sets</code>, each object in a <code>WeakSet</code> can only appear once; all objects in a <code>WeakSet</code>&#x27;s collection are unique.</p><p>The following are the primary distinctions between the <u><code><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\" target=\"_blank\" rel=\"noopener noreferrer\">Set</a></code></u> object and the <code>WeakSet</code> object: <code>WeakSets</code> are merely collections of items. They, unlike <code>Sets</code>, cannot hold arbitrary values of any type. The <code>WeakSet</code> is weak, which means that references to items in it are kept weak. If there are no additional references to an item in the <code>WeakSet</code>, those objects can be garbage collected.</p><p>Simply put, a <code>Set</code> is similar to an array in that it can only contain unique values, but it can still be iterated using techniques like <code>for</code> loops and <code>.forEach</code>.</p><p><code>WeakSet</code>, like a <code>Set</code>, is a collection of items distinct from one another. Still, it varies because <code>WeakSet</code> may only hold objects and cannot have arbitrary values like texts or integers.</p><p>Finally, as the name implies, <code>WeakSets</code> are weak, as they employ weak references.</p><p>Using weak references has the interesting side effect of rendering <code>WeakSet</code> uncountable. There is no means to iterate through the items included within the collection since there is no list of current objects stored in it; they are weakly referenced and may be destroyed at any moment.</p><p>A <code>WeakSet</code> is a collection of one-of-a-kind items. <code>WeakSets</code>, as the name implies, make use of weak references. <code>WeakSet()</code>  has the following properties:</p><ul><li>It can only hold items</li><li>Objects in the set may be accessible from other locations</li><li>It is not possible to loop through it</li></ul><p><code>WeakSet()</code>, like <code>Set()</code>, has access to similar <code>.add()</code>, <code>.has()</code>, and <code>.delete()</code> methods.</p><p>Here&#x27;s an example of <code>WeakSet</code> in action, along with the methods we can call on it:</p><pre>const meals = new WeakSet();<br>const bread = { name: &#x27;Wheat Bread&#x27; };<br><br>const rice = { name: &#x27;Basmati rice&#x27; };<br><br>meals.add(bread); //add bread to the orderSet<br><br>meals.add(rice); //add rice to the orderSet<br><br>meals.has(bread); //True<br><br>meals.has(rice); //True<br><br>meals.delete(bread); // removes bread from the set<br>meals.has(bread); // false, bead has been removed<br>meals.has(rice); // true, rice is retained</pre><h2 id=\"24sbt\">Conclusion</h2><p>Although <code>WeakMaps</code> and <code>WeakSets</code> are rarely used in JavaScript, they are useful for rare scenarios and building a good foundation. Strong references are used in most cases. <code>WeakMaps</code> and <code>WeakSets</code> temporarily store data as they save us the headache of clearing or cleaning up the memory.</p>\n\n    <figure data-rt-type=\"video\" data-rt-align=\"center\">\n        <!-- strchf script -->\n<script>\n        if(window.strchfSettings === undefined) window.strchfSettings = {};\n    window.strchfSettings.stats = {url: \"https://pieces-app.storychief.io/en/memory-management-introduction-to-how-weak-references-work-in-javascript?id=1400680548&type=26\",title: \"Memory Management: Introduction to Weak References in JavaScript\",id: \"f48cd0d8-d254-4e17-a18e-3d20939412eb\"};\n            (function(d, s, id) {\n      var js, sjs = d.getElementsByTagName(s)[0];\n      if (d.getElementById(id)) {window.strchf.update(); return;}\n      js = d.createElement(s); js.id = id;\n      js.src = \"https://d37oebn0w9ir6a.cloudfront.net/scripts/v0/strchf.js\";\n      js.async = true;\n      sjs.parentNode.insertBefore(js, sjs);\n    }(document, 'script', 'storychief-jssdk'))\n    </script>\n<!-- End strchf script -->    </figure>\n",
  "Date": "Fri Jan 06 2023 16:31:10 GMT+0000 (Coordinated Universal Time)",
  "Author": "Nwakor Chidinma Favour",
  "Author Photo": "https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63b85731a83ac732ffa784dc_T016ZUW6H97-U042J8CS3BR-a4e60b2d3209-512_c5f27440f69aa3c3471d558d270beb65_1000.jpeg",
  "AMP URL": "",
  "TOC based on...": "h2,h3",
  "Tags": "javascript-8; memory",
  "CTA": "",
  "CTA link": "",
  "Canonical URL": ""
}
