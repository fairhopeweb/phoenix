{
  "Title": "Flutter Game: Build a Pong Game with Flutter Flame",
  "Slug": "flutter-game-pong-game-flame",
  "Collection ID": "642da2c43fe34c364a69857f",
  "Item ID": "642da2c43fe34c513f6989d3",
  "Created On": "Wed Sep 21 2022 15:25:52 GMT+0000 (Coordinated Universal Time)",
  "Updated On": "Tue Mar 28 2023 15:35:24 GMT+0000 (Coordinated Universal Time)",
  "PublishedOn": "Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)",
  "MainImage": "https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd522ced888d66a24221d4_flutter-pong_d4e57c6c71cfed2a205d0cbf935b2891_2000.jpeg",
  "Post summary": "Let's Build a Flutter Game! Building apps with Flutter is simple, let’s create the classic pong game using the Flame game engine.",
  "FullPost": "<p>Building apps with Flutter is really cool. You know what’s cooler? <br>Building games. This article will show you how to build a Flutter game from start to finish with a Flutter Flame tutorial.</p><p>Let’s create a Flutter game! We can build the classic pong game in Flutter using the 🔥<a href=\"https://flame-engine.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Flame</a> game engine.</p><p>Flame is a 2D game engine built for Flutter. It’s built on top of the framework and simplifies game development. Flame provides us with everything we’ll need to build a flutter game.</p><figure class=\"w-richtext-figure-type-video w-richtext-align-center\" style=\"padding-bottom: 37.5%;\" data-rt-type=\"video\" data-rt-align=\"center\" data-rt-max-width=\"\" data-rt-max-height=\"37.5%\" data-rt-dimensions=\"384:240\" data-page-url=\"https://vimeo.com/744509891\"><div><iframe src=\"https://player.vimeo.com/video/744509891?h=fee931dbde&amp;app_id=122963\" width=\"384\" height=\"240\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen title=\"final_demo\"></iframe></div><figcaption>Flutter Game | Pong Game with Flame</figcaption></figure><p>Some of the concepts we’ll learn are: flutter game development</p><ul><li>Collision detection in Flame</li><li>Building a simple AI opponent</li><li>Using Flame audio flutter</li></ul><p><strong>Note:</strong> Knowledge of the basics of Flutter and Flame are required for this tutorial. Check out the <u><a href=\"https://docs.flame-engine.org/1.3.0/index.html#\">Flutter Flame docs</a></u> if you’re new to the engine.</p><p>Grab a coffee; let’s get started! Flutter game on! 🎮</p><h2 id=\"67ite\">Flutter Game: Getting Started with game development in flutter</h2><p>Let’s create a new flutter project and enter the folder with the following commands:</p><pre>flutter create pong_game<br>cd pong_game</pre><p>Next, add the required Flame dependencies:</p><pre>flutter pub add flame</pre><p>For the game, our file structure will look like this:</p><pre>-lib/<br>··|---main.dart<br>··|---pong_game.dart<br>··|---player_paddle.dart<br>··|---ball.dart<br>··|---ai_paddle.dart<br>··|---scoretext.dart</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=fc3248810b\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>We’ll update our main.dart with the following code:</p><pre>void main() {<br>  final game = PongGame();<br>  runApp(GameWidget(game: game));<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=310c4baaa2\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Now, in the pong_game.dart file, we’ll add the the following:</p><pre>class PongGame extends FlameGame<br> with HasCollisionDetection, HasKeyboardHandlerComponents {<br> PongGame();<br> <br> @override<br> Future&lt;void&gt; onLoad() async {}<br> <br> @override<br> @mustCallSuper<br> KeyEventResult onKeyEvent(<br>   RawKeyEvent event,<br> Set&lt;LogicalKeyboardKey&gt; keysPressed,<br> ) {<br> super.onKeyEvent(event, keysPressed);<br> <br> return KeyEventResult.handled;<br> }<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=bc43458be4\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we have the <code>PongGame</code><em> </em>declared. Notice that it has two mixings: <code>HasCollisionDetection</code> and <code>HasKeyboardHandlerComponents</code>. This will let Flame know that our game is going to use these two things and allow us to work with collision detection and take keyboard inputs at the component level.</p><p>We’re also overriding the <code>onKeyEvent</code> here and returning <code>KeyEventResult.handled</code>. This is because if you’re on macOS, then you’ll notice key press sounds as you’re receiving keyboard inputs in the game. Returning <code>KeyEventResult.handled</code><em> </em>will disable those sounds.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Flutter game example.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2d002e460d860b3f4970_image4_72ed6baeec79e636ccc5b099718d2d57_800.png\"></div><figcaption>Flutter Game: Flutter Flame Example</figcaption></figure><h2 id=\"feq26\">Flutter Flame Collision Detection </h2><p>Before moving on to building our game, let’s take a look at how collision detection works in Flame. This will be important for us as we’ll need to set up HitBoxes for our game bodies, know when these bodies collide with each other and react accordingly.</p><h3 id=\"9ng2d\">HitBoxes</h3><p>In many game systems, collision detection works by having a HitBox around the game object. HitBoxes react to collisions and can send callbacks with the collision information.</p><p>Flame supports adding different HitBoxes to our components like <code>PolygonHitBox</code>, <code>RectangleHitBox</code>, <code>CircleHitBox</code> or <code>ScreenHitBox</code>, which is usually used for declaring the world boundaries/screen edges that components may collide with.</p><p><strong>Note:</strong> We can use multiple HitBoxes on a component to provide more accurate collision detection for it. For example, a game character can have separate HitBoxes around its arms, its legs, and so on.</p><h3 id=\"d8fth\"><strong>Enable Collision Detection</strong></h3><p>For this, we first need to add the <code>HasCollisionDetection</code><em> </em>mixing to our Flame game.</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\" add &quot;HasCollisionDetection&quot; .\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d6b313f4948_image9_dea7a62fbd18753619d0050c38babbb5_800.png\"></div></figure><p>For the components, we want to get notified when they collide with other bodies that are capable of collision. For this, we’ll add the <code>CollisionCallbacks</code> mixing to those components.</p><pre>class MyComponent extends PositionComponent with CollisionCallbacks {<br><br><br> @override<br> void onCollision(Set&lt;Vector2&gt; intersectionPoints, PositionComponent other) {<br> // TODO: implement onCollision<br> super.onCollision(intersectionPoints, other);<br>  }  <br><br> @override<br> void onCollisionStart(Set&lt;Vector2&gt; intersectionPoints, PositionComponent other) {<br> // TODO: implement onCollisionStart<br> super.onCollisionStart(intersectionPoints, other);<br>  }<br><br> @override<br> void onCollisionEnd(PositionComponent other) {<br> // TODO: implement onCollisionEnd<br> super.onCollisionEnd(other);<br>  }<br><br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=959d4ca464\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Adding this mixing allows us to be notified when a body collides with other bodies through callbacks such as <code>onCollision</code>, <code>onCollisionStart</code><em> </em>and<em> </em><code>onCollisionEnd</code>. These callbacks also provide the intersection points and the reference to the other body the component is colliding with.</p><p><strong>Note:</strong> The <a href=\"https://docs.flame-engine.org/1.0.0/collision_detection.html\" target=\"_blank\" rel=\"noopener noreferrer\">Collision Detection API</a> only lets us know when two bodies collide. What happens upon collision is up to us!</p><p>Now, let’s move on to the different components of our game.</p><h2 id=\"67iis\">Game Components</h2><p>Our Pong game mainly consists of the following components:</p><ul><li>Game Boundaries</li><li>Player paddle</li><li>Ball</li><li>AI opponent paddle</li><li>Scoring system</li></ul><h3 id=\"3cikk\">Game Boundaries</h3><p>Our ball is going to collide with the boundaries of our game/screen. We need to know when this happens so that we can either bounce it off of the top or bottom of the screen or update the players’ score if it’s colliding with the left or right of the screen.</p><p>For this, we’ll declare game boundaries by adding the <code>ScreenHitBox</code> component.</p><p>Replace the <code>onload</code><em> </em>method within <code>PongGame</code> with the following:</p><pre>@override<br> Future&lt;void&gt; onLoad() async {<br>   addAll([<br>     ScreenHitbox()<br>   ]);<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=fce246ae92\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p><code>ScreenHitBox</code> will represent the edges of our game screen. If any other components collide with the edges, we’ll be notified of the collision.</p><h3 id=\"1pl4i\">Player Paddle</h3><p>Now, we’ll add the player paddle to the flutter game tutorial.</p><p>Create a new file called <code>player_paddle.dart</code> and add the following to it:</p><pre>// TODO: add key event enum<br> <br>class PlayerPaddle extends PositionComponent<br> with HasGameRef&lt;FlameGame&gt;, CollisionCallbacks {<br> late final RectangleHitbox paddleHitBox;<br> late final RectangleComponent paddle;<br> <br> // TODO: add variable key event and speed variables<br> <br> @override<br> Future&lt;void&gt;? onLoad() {<br> // TODO: implement onLoad<br> <br> final worldRect = gameRef.size.toRect();<br> <br>   size = Vector2(10, 100);<br>   position.x = worldRect.width * 0.9 - 10;<br>   position.y = worldRect.height / 2 - size.y / 2;<br>   paddle = RectangleComponent(<br>     size: size,<br>     paint: Paint()..color = Colors.blue,<br>   );<br> <br>   paddleHitBox = RectangleHitbox(<br>     size: size,<br>   );<br> <br>   addAll([<br>     paddle,<br>     paddleHitBox,<br>   ]);<br> <br> // TODO: add keyboard listener component<br> <br> return super.onLoad();<br> }<br> <br> //TODO: add update code for moving paddle<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=d72c49a5a3\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Our <code>PlayerPaddle</code><em> </em>is a <code>PositionComponent</code> with the <code>HasGameRef</code> and <code>CollisionCallbacks</code> mixing. The <code>HasGameRef</code> mixing will allow us to get the game reference and check for any values in our game world. <code>CollisionCallbacks</code> mixing, as we discussed, will add support for setting collision callbacks.</p><p>In the <code>onLoad</code> method, we’re setting the size for our paddle component and positioning it at the center-right of the screen. We also added a <code>RectangleHitBox</code><em> </em>of the same size as our paddle so that it can detect collisions.</p><p>Within the <code>onload</code> method of the <code>PongGame</code><em> </em>component<em>, </em>add the <code>PlayerPaddle</code>:</p><pre>@override<br> Future&lt;void&gt; onLoad() async {<br>   addAll(<br>     [<br>       ...<br>       .....<br>       PlayerPaddle(),<br> <br>     ],<br>   );<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=432c44aadd\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Run Flutter flame classic pong.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2d002e460d0cb63f496e_image3_483dd41fd525dca771cdff4be556f607_800.png\"></div></figure><h3 id=\"24v83\">Player keyboard controls</h3><p>Flame offers two different ways to take keyboard inputs; one at the game level and the other at the component level.</p><p>Let’s take a look at receiving keyboard inputs at the component level. You can learn more about other ways of taking keyboard input <u><a href=\"https://docs.flame-engine.org/1.3.0/flame/inputs/keyboard-input.html\" target=\"_blank\" rel=\"noopener noreferrer\">here</a></u>.</p><p>We’ll make sure our <code>PongGame</code> component has the <code>HasKeyboardHandlerComponents</code> mixing. Within our <code>PlayerPaddle</code> component, we’ll use the <code>KeyboardListenerComponent</code>, through which we can set callbacks for different key events.</p><p>Add the following component within your <code>onload</code> method:</p><pre>add(<br>     KeyboardListenerComponent(<br>       keyDown: {<br>         LogicalKeyboardKey.arrowDown: (keysPressed) {<br> <br> return true;<br>         },<br>         LogicalKeyboardKey.arrowUp: (keysPressed) {<br> <br> return true;<br>         },<br>       },<br>       keyUp: {<br>         LogicalKeyboardKey.arrowDown: (keysPressed) {<br> <br> return true;<br>         },<br>         LogicalKeyboardKey.arrowUp: (keysPressed) {<br> <br> return true;<br>         },<br>       },<br>     ),<br>   );</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=1cc447b348\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>This adds the <code>KeyboardListenerComponent</code>. We’ll be registering callbacks for <code>arrowDown</code> and <code>arrowUp</code> events when the respective keys are either pressed or released.</p><h3 id=\"769s9\">Moving Player Paddle</h3><p>Now that we’re receiving keyboard events, let’s see how we can move our paddle.</p><p>Let’s try updating our paddle position along the y-axis by 50 when the down arrow is pressed and by -50 when the up arrow is pressed. Update <code>keyDown</code> within the <code>KeyboardListenerComponent</code> with the following (you may need to hot restart your game to reflect the new changes):</p><pre>keyDown: {<br>         LogicalKeyboardKey.arrowDown: (keysPressed) {<br>           position.y += 50;<br> <br> return true;<br>         },<br>         LogicalKeyboardKey.arrowUp: (keysPressed) {<br>           position.y -= 50;<br> <br> return true;<br>         },<br>       },</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=bb6849bba2\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Run game in Flutter using Flame.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d18683f4963_image5_7a88eabd1389017369b8a6a57a00c072.gif\"></div><figcaption>Flutter Game</figcaption></figure><p>You’ll see that the paddle moves, but its movement is janky. It’s not smooth. 🤷</p><p>This is because the position is not updated consistently with the passage of time. To achieve smooth movement, we’ll need to update its position from within the <code>update</code> method.</p><p>Currently, in Flame, there’s no possible way to know which keys are pressed within the <code>update</code> method. For this, we’ll first set up a variable that’ll tell us which key was pressed so we can update the position accordingly.</p><p>Replace the <code>// TODO: add key event enum</code> within <code>player_paddle.dart</code> with the following code:</p><pre>enum KeyEventEnum {<br>  up,<br>  down,<br>  none,<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=8aee42a78b\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Declare the following variables within the paddle component:</p><pre>KeyEventEnum keyPressed = KeyEventEnum.none;<br> static const double speed = 400;</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=7c044eb7b0\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><ol type=\"1\"><li><code>keyPressed</code>: Lets us know which key is pressed. When none of the keys are pressed, we’ll update this variable to <code>KeyboardEventEnum.none</code>, so we can know to stop updating the position.</li><li><code>speed</code>: Paddle moving speed.</li></ol><p>Replace the previously added <code>KeyboardListenerComponent</code> with the following:</p><pre>add(<br>      KeyboardListenerComponent(<br>        keyDown: {<br>          LogicalKeyboardKey.arrowDown: (keysPressed) {<br>            keyPressed = KeyEventEnum.down;<br><br> return true;<br>          },<br>          LogicalKeyboardKey.arrowUp: (keysPressed) {<br>            keyPressed = KeyEventEnum.up;<br><br> return true;<br>          },<br>        },<br>        keyUp: {<br>          LogicalKeyboardKey.arrowDown: (keysPressed) {<br>            keyPressed = KeyEventEnum.none;<br><br> return true;<br>          },<br>          LogicalKeyboardKey.arrowUp: (keysPressed) {<br>            keyPressed = KeyEventEnum.none;<br><br> return true;<br>          },<br>        },<br>      ),<br>    );</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=a14248b436\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we’re doing two things:</p><ol type=\"1\"><li>Setting the <code>KeyboardEventEnum</code> to up/down based on the key pressed.</li><li>Resetting it to <code>KeyEventEnum.none</code> when the key is released.</li></ol><p>Add the following code, which overrides the update method for the component:</p><pre>@override<br> void update(double dt) {<br> // TODO: implement update<br> super.update(dt);<br> if (keyPressed == KeyEventEnum.down) {<br> final updatedPosition = position.y + speed * dt;<br> if (updatedPosition &lt; gameRef.size.y - paddle.height) {<br>       position.y = updatedPosition;<br>     }<br>   }<br> if (keyPressed == KeyEventEnum.up) {<br> final updatedPosition = position.y - speed * dt;<br> if (updatedPosition &gt; 0) {<br>       position.y = updatedPosition;<br>     }<br>   }<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=39e043aef0\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we update the paddle position based on the key pressed. This time, instead of passing a fixed displacement, we’re updating the position by the <em>speed*dt(=distance) </em>value.</p><p>We also check if our paddle is going out of the bounds of the game window. If it is, then we stop updating the position.</p><p>We can test our updates by holding down the up or down arrow keys and seeing the paddle move smoothly.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Run flutter flame.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d46093f496c_image14_a3e95eae1aab106b4125b790cc9095b6.gif\"></div><figcaption>Flutter Game</figcaption></figure><h2 id=\"c0leh\">Flutter Game: <strong>Adding the Ball</strong></h2><p>Create a new file called ball.dart and add the following code to it:</p><pre>import &#x27;dart:math&#x27; as math;<br> <br>class Ball extends CircleComponent<br> with HasGameRef&lt;PongGame&gt;, CollisionCallbacks {<br> Ball() {<br>   paint = Paint()..color = Colors.white;<br>   radius = 10;<br> }<br> <br> // 1.<br> late Vector2 velocity;<br> // 2.<br> static const double speed = 500;<br> // 3.<br> static const degree = math.pi / 180;<br> <br> // 6.<br> @override<br> Future&lt;void&gt;? onLoad() {<br>   _resetBall;<br> final hitBox = CircleHitbox(<br>     radius: radius,<br>   );<br> <br>   addAll([<br>     hitBox,<br>   ]);<br> <br> return super.onLoad();<br> }<br> <br> @override<br> void update(double dt) {<br> super.update(dt);<br>    position += velocity * dt;<br>  }<br> <br> <br> // 4.<br> void get _resetBall {<br>   position = gameRef.size / 2;<br> final spawnAngle = getSpawnAngle;<br> <br> final vx = math.cos(spawnAngle * degree) * speed;<br> final vy = math.sin(spawnAngle * degree) * speed;<br>   velocity = Vector2(<br>     vx,<br>     vy,<br>   );<br> }<br> <br> // 5.<br> double get getSpawnAngle {<br> final sideToThrow = math.Random().nextBool();<br> <br> final random = math.Random().nextDouble();<br> final spawnAngle = sideToThrow<br>       ? lerpDouble(-35, 35, random)!<br>       : lerpDouble(145, 215, random)!;<br> <br> return spawnAngle;<br> }<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=1b4245b15f\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Our ball is a <code>CircleComponent</code>, which is a <code>PositionedComponent</code> but circular with <code>HasGameRef</code> and <code>CollisionCallbacks</code> mixing. We also defined the color and radius of the ball within its constructor.</p><p>Along with defining the HitBox for our ball in the <code>onload</code><em> </em>method, we have some other things here:</p><ol type=\"1\"><li><code>velocity</code>: A 2D vector representing the ball&#x27;s velocity.</li><li><code>speed</code>: A constant value that will calculate the ball&#x27;s velocity.</li><li><code>degree</code>: The degree to radian constant.</li><li><code>_resetBall</code>: Spawns (positions) the ball at the center of the screen and launches it in a random direction with some initial velocity.</li><li><code>getSpawnAngle</code>: Calculates the angle at which the ball will be thrown upon spawning.</li></ol><p>Finally, within the <code>update</code> method, we update the ball&#x27;s position with respect to its <code>velocity</code> and the time passed, i.e., <code>dt</code><em>.</em></p><p>Let’s add the ball component to our <code>PongGame</code> component:</p><pre>@override<br> Future&lt;void&gt; onLoad() async {<br>   addAll(<br>     [<br>       ...<br>       .....<br>       Ball(),<br>     ],<br>   );<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=3bd642b823\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Runing the pong game that&#39;s starting to take shape.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d4f7e3f495f_image2_9b36be6ed231327334326d9aae2c124b.gif\"></div><figcaption>Flutter Game</figcaption></figure><h3 id=\"8pnrc\">Collision Detection with the Ball</h3><p>Now that we have our <code>Ball</code> spawning in the center of the screen and moving, let&#x27;s get to the interesting part of the game: making the ball bounce when it collides with a <code>PlayerPaddle</code> or the top and bottom edges of the game.</p><p>Add the following code, which overrides the <code>onCollisionStart</code><em> </em>method within the <code>Ball</code> component.</p><pre>@override<br> @mustCallSuper<br> void onCollisionStart(<br> Set&lt;Vector2&gt; intersectionPoints,<br>   PositionComponent other,<br> ) {<br> super.onCollisionStart(intersectionPoints, other);<br> final collisionPoint = intersectionPoints.first;<br><br> // TODO: add edges collision update<br> <br>  // TODO: add player paddle collision update<br> <br> // TODO: add ai paddle collision update<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=8aa94480c9\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>This callback provides us with the intersection/collision points for our component and the ref to the component we are colliding with. These will be useful in the next section, where we deal with collision logic for different bodies.</p><h3 id=\"adaj3\">Edge Collision Update</h3><p>We’ll first update the ball velocity to bounce off of the top and bottom edges of the screen. Replace the <code>// TODO: add edge collision update</code> with the following code:</p><pre>if (other is ScreenHitbox) {<br> // Left Side Collision<br> if (collisionPoint.x == 0) {<br> // TODO: update player score<br>     }<br> // Right Side Collision<br> if (collisionPoint.x == gameRef.size.x) {<br> // TODO: update ai score<br>     }<br> // Top Side Collision<br> if (collisionPoint.y == 0) {<br>       velocity.x = velocity.x;<br>       velocity.y = -velocity.y;<br>   // TODO: play the collision sound<br>     }<br> // Bottom Side Collision<br> if (collisionPoint.y == gameRef.size.y) {<br>       velocity.x = velocity.x;<br>       velocity.y = -velocity.y;<br>  // TODO: play the collision sound<br>     }<br>   }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=afa941beb6\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we’re first checking if the body that our ball collided with is <code>ScreenHitBox</code> or not. If it is, we check for the edge with which our ball collided.</p><p>We don’t want the ball to bounce off of the left and right edges. We’ll later add some code there to update the players’ scores.</p><p>If it’s the top or bottom edge, we reverse the ball’s <code>velocity</code> in the y direction. Test it by changing the ball’s <code>spawnAngle</code><em> </em>to <strong>90 </strong>such that it’ll be thrown towards the top or bottom edges.</p><p>Build &amp; run: </p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Use &quot;spawnAngle&quot; for the pong game to move at an angle within this pong game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460dc5b83f4962_image1_4f5588e134b95813c36399572affdcf1.gif\"></div><figcaption>Flutter Game</figcaption></figure><h3 id=\"6qm6v\">Paddle Collision Update</h3><p>Replace the <code>// TODO: paddle collision update</code> with the following:</p><pre>if (other is PlayerPaddle) {<br> final paddleRect = other.paddle.toAbsoluteRect();<br> <br>     updateBallTrajectory(collisionPoint, paddleRect);<br> // TODO: play the collision sound<br>   }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=82044fa5e4\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>If the collided object is the <code>PlayerPaddle</code><em>, </em>we first calculate the <code>paddleRect</code>, which is the bounding rectangle of the component in the global coordinate space.</p><p>Within the <code>Ball</code> component, add the following method:</p><pre>void updateBallTrajectory(Vector2 collisionPoint, Rect paddleRect) {<br> final isLeftHit = collisionPoint.x == paddleRect.left;<br> final isRightHit = collisionPoint.x == paddleRect.right;<br> final isTopHit = collisionPoint.y == paddleRect.bottom;<br> final isBottomHit = collisionPoint.y == paddleRect.top;<br> <br> final isLeftOrRight = isLeftHit || isRightHit;<br> final isTopOrBottom = isTopHit || isBottomHit;<br> <br> if (isLeftOrRight) {<br>     velocity.x = -velocity.x;<br>     velocity.y = velocity.y;<br>   }<br> if (isTopOrBottom) {<br>     velocity.x = velocity.x;<br>     velocity.y = -velocity.y;<br>   }<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=24ab4e95b7\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>This method will reverse the ball’s <code>velocity</code> along the x- or y-axis, depending on where it touches the paddle, which is known by checking the <code>collisionPoint</code> with the <code>paddleRect</code> position. If the collision is on the left or right side, we reverse the <code>velocity</code> along the x-axis. If the collision is on the top or bottom, we reverse the velocity along the y-axis.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Run the game with the moving paddle and working pong game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d35593f4960_image12_b4d9343f319966c1b84e562634bdd4dd.gif\"></div><figcaption>Flutter Game</figcaption></figure><h2 id=\"d3q18\">Flutter Game: AI Paddle</h2><p>Now that we’ve got the ball bouncing off the edges and the paddle, let’s add the AI opponent 🤖 you can play against.</p><p>It’ll be very similar to how we did the <code>PlayerPaddle</code>; the only part that’s going to be different is how it moves.</p><p>Add the following code to a new file called ai_paddle.dart:</p><pre>class AIPaddle extends PositionComponent<br> with HasGameRef&lt;FlameGame&gt;, CollisionCallbacks {<br> late final RectangleHitbox paddleHitBox;<br> late final RectangleComponent paddle;<br> <br> @override<br> Future&lt;void&gt;? onLoad() {<br> // TODO: implement onLoad<br> <br> final worldRect = gameRef.size.toRect();<br> <br>   size = Vector2(10, 100);<br>   position.x = worldRect.width * 0.1;<br>   position.y = worldRect.height / 2 - size.y / 2;<br>   paddle = RectangleComponent(<br>     size: size,<br>     paint: Paint()..color = Colors.red,<br>   );<br> <br>   paddleHitBox = RectangleHitbox(<br>     size: size,<br>   );<br> <br>   addAll([<br>     paddle,<br>     paddleHitBox,<br>   ]);<br> <br> return super.onLoad();<br> }<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=6be148818d\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Construction of our AI paddle is very similar to the <code>PlayerPaddle</code>, except we position it at the center on the left side.</p><p>Don’t forget to add the <code>AIPaddle</code> component to our <code>PongGame</code> component:</p><pre>@override<br> Future&lt;void&gt; onLoad() async {<br>   addAll(<br>     [<br>       ...<br>       .....<br>       AIPaddle(),<br>     ],<br>   );<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=67934c853f\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Add a flutter game opponent.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460def233f4961_image13_083c18d17fe4f03312785c10f6d9cae4_800.png\"></div><figcaption>Flutter Game</figcaption></figure><h3 id=\"fkva5\">AI Paddle Movement Logic</h3><p>There are many different ways to build this AI opponent, control its behavior, detect how it should move, set how fast it should move and decide how challenging it should be to play against.</p><p>For our game, we won’t be building an AI that will be literally impossible to beat, just a simple AI that we can play against peacefully. ✌️</p><p>Our AI Paddle will follow two rules depending on the ball&#x27;s position:</p><ol type=\"1\"><li>If the <code>AIPaddle</code> is below the <code>Ball</code>, it should move up towards the ball.</li><li>If the <code>AIPaddle</code> is above the <code>Ball</code>, it should move down towards the ball.</li></ol><p>Following these rules, override the <code>update</code> method for <code>AIPaddle</code> with the following:</p><pre>@override<br> void update(double dt) {<br> // TODO: implement update<br> super.update(dt);<br> <br> final ball = gameRef.children.singleWhere((child) =&gt; child is Ball) as Ball;<br> <br> if (ball.y &gt; position.y) {<br>     position.y += (400 * dt);<br>   }<br> <br> if (ball.y &lt; position.y) {<br>     position.y -= (400 * dt);<br>   }<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=970440b656\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we first get the reference to the ball from our game world. Depending on the earlier rules we defined, we move the <code>AIPaddle</code><em> </em>up or down.</p><p>In some cases, the <code>AIPaddle</code> will follow the ball even if it goes outside the game boundaries; to prevent this, replace the code after we query/get the ball with the following:</p><pre>final ballPositionWrtPaddleHeight = ball.y + (size.y);<br> final isOutOfBounds =<br>       ballPositionWrtPaddleHeight &gt; gameRef.size.y || ball.y &lt; 0;<br> <br> if (!isOutOfBounds) {<br> if (ball.y &gt; position.y) {<br>       position.y += (400 * dt);<br>     }<br> <br> if (ball.y &lt; position.y) {<br>       position.y -= (400 * dt);<br>     }<br>   }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=80b54181a3\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Here, we check if the updated position will be within the boundaries of our game world. If it isn’t, we don’t update the position of the paddle.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Allow your opponent to move within the flutter game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d51623f4964_image11_3b66b431322d9f152fabf7d7051480ce.gif\"></div><figcaption>Flutter Game</figcaption></figure><h3 id=\"295gj\">AI Collision Update</h3><p>Within the <code>Ball</code> component’s <code>update</code> method, replace<em> </em><code>// TODO: add AI paddle collision update</code> with the following:</p><pre>if (other is AIPaddle) {<br> final paddleRect = other.paddle.toAbsoluteRect();<br><br>      updateBallTrajectory(collisionPoint, paddleRect);<br><br> // TODO: play the collision sound<br>    }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=c2944ca779\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Now, our ball will also collide with the <code>AIPaddle</code> and bounce off of it after a collision.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Add collision update to pong game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d133f3f496b_image6_1f84df923e8c59560d40545849d9ebfa.gif\"></div><figcaption>Flutter Game</figcaption></figure><h2 id=\"9teho\">Add the Scoring System</h2><p>Now onto the final part of the game— adding the scoring system. Create a new file called score_text.dart and add the following to it:</p><pre>class ScoreText extends TextComponent with HasGameRef&lt;PongGame&gt; {<br> late int score;<br> <br> ScoreText.aiScore({<br> this.score = 0,<br> })  : _textPaint = TextPaint(textDirection: TextDirection.ltr),<br> super(<br>         anchor: Anchor.center,<br>       );<br> <br> ScoreText.playerScore({<br> this.score = 0,<br> })  : _textPaint = TextPaint(textDirection: TextDirection.rtl),<br> super(<br>         anchor: Anchor.center,<br>       );<br> <br> late final TextPaint _textPaint;<br> <br> @override<br> Future&lt;void&gt;? onLoad() {<br>   score = 0;<br> final textOffset =<br>       (_textPaint.textDirection == TextDirection.ltr ? -1 : 1) * 50;<br>   position.setValues(gameRef.size.x / 2 + textOffset, gameRef.size.y * 0.1);<br>   text = score.toString();<br> <br> return super.onLoad();<br> }<br> <br> @override<br> void render(Canvas canvas) {<br>   _textPaint.render(canvas, &#x27;$score&#x27;, Vector2.zero());<br> }<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=50b444a1e9\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>This <code>ScoreText</code> will hold and display the score for each player. It has two factory constructors; one for <code>aiScore</code> and one for <code>player</code>. Within its <code>onLoad</code> method, we position our scores at the top center and offset them a little in the left or right direction based on whether it’s the player’s or the AI’s score.</p><p>We’ve also overridden the <code>render</code><em> </em>method to show the latest score as it’s updated.</p><p>Now, within our <code>PongGame</code><em> </em>component, add the following <code>aiScore</code> and <code>playerScore</code> variables which will hold the <code>ScoreText</code> component:</p><pre>late final ScoreText aiPlayer;<br>late final ScoreText player;</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=d927459402\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Update the <code>addAll</code> method by adding these two components:</p><pre>aiPlayer = ScoreText.aiScore(),<br>player = ScoreText.playerScore(),</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=0e0443b912\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Now that we have the score components in place, the next thing we want to do is update the scores whenever the player or the AI scores.</p><h3 id=\"d3ofv\">Update the Score</h3><p>Within the <code>onCollisionStart</code> method of our <code>Ball</code><em> </em>component<em>, </em>replace the code from <code>// Left Side Collision</code><em> </em>to<em> </em><code>// Right Side Collision</code><em> </em>with the following:</p><pre>// Left Side Collision<br> if (collisionPoint.x == 0) {<br> final player = gameRef.player;<br>       updatePlayerScore(player);<br>     }<br> // Right Side Collision<br> if (collisionPoint.x == gameRef.size.x) {<br> final player = gameRef.aiPlayer;<br>       updatePlayerScore(player);<br>     }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=11ae4abbb5\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Add the following <code>updatePlayerScore</code> method in the <code>Ball</code><em> </em>component:</p><pre>import &#x27;dart:async&#x27; as dartAsync;<br> <br>void updatePlayerScore(ScoreText player) {<br>   player.score += 1;<br>   dartAsync.Timer(const Duration(seconds: 1), () {<br>     _resetBall;<br>   });<br> }</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=5e5c4ebd3b\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>This method takes in the <code>ScoreText</code> object and increments its <code>score</code> by 1. After that, we set up a timer for 1 second to respawn the ball in the center by calling <code>_resetBall</code>.</p><p>Now as you or the AI opponent misses the ball, the opposite player will get the point and their score will be updated.</p><p>Build &amp; run:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Run the AI opponent in the flutter game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d0aea3f496d_image8_0d0906c5587f39462b8bbbeb9d1f3dc1.gif\"></div></figure><h2 id=\"52vq4\">Flutter Game: Adding Collision Audio</h2><p>A game without audio is definitely not something you would play. So, let’s add a collision sound whenever the ball collides with other game bodies.</p><p>Run the following command to add the <strong>flame_audio</strong> dependency:</p><pre>flutter pub add flame_audio</pre><p>Once that’s done, download the audio file for the collision sound <u><a href=\"https://github.com/rutvik110/Pong-Game/tree/master/assets/audio\">here</a></u>. Add the audio files to the <code>assets/audio</code> folder. Make sure to add the audio folder to the assets section in the pubspec as shown:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Download the audio file for the collision sound for your flutter game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cff2e460d0e7f3f4949_image10_f4efcd935651f61d65259dd48d73cfc5_800.png\"></div><figcaption>Flutter Flame Audio</figcaption></figure><p>Let’s add the following method in our <code>Ball</code> component:</p><pre>void get _playCollisionAudio {<br>  FlameAudio.play(&quot;ball_hit.wav&quot;);<br>}</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=6b35449a4c\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>We’ll need to play the collision sound after every collision. Within the <code>onCollisionStart</code> method of the <code>Ball</code> component, replace the <code>//TODO: play the collision sound</code> with:</p><pre>_playCollisionAudio</pre><p><u><a href=\"https://takrutvik.pieces.cloud/?p=f9454e864c\" target=\"_blank\" rel=\"noopener noreferrer\">Save this code</a></u></p><p>Final demo:</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Successfully playing your pong game.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/641a021b177c3b6221a9b66e_ezgifcom-video-to-gif_2e3e5f6d95abb88dfaea4fc6ad782656.gif\"></div><figcaption>Final Demo of the Pong Game</figcaption></figure><h2 id=\"2q6c3\">Bonus</h2><p>In the final demo, our Ball speeds up a little when it collides with either the player’s paddle or the AI paddle. For this, we’re simply increasing the ball&#x27;s velocity in the y-direction by giving it some additional <code>nudgeSpeed</code>. I suggest making the nudge speed 300/200, but you can make it whatever you prefer.</p><figure class=\"w-richtext-figure-type-image w-richtext-align-center\" data-rt-type=\"image\" data-rt-align=\"center\"><div><img alt=\"Bonus code to all the pong game ball to speed up.\" src=\"https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2d002e460dcb313f496f_image7_f0e37aba358c898cb5e1bea0f549557d_800.png\"></div><figcaption>Flutter Game</figcaption></figure><h2 id=\"85fl5\">Flutter Game: Summary</h2><p>Congrats! 🥳 We just built a Pong game with Flame!🔥</p><p>While building this game, we learned about:</p><ul><li>CollisionDetection API in Flame.</li><li>Building a simple AI opponent.</li><li>Adding a scoring system to the game.</li><li>Adding audio to your game.</li></ul><p>You can download the source code <u><a href=\"https://github.com/rutvik110/Pong-Game\" target=\"_blank\" rel=\"noopener noreferrer\">here</a></u>.</p><h3 id=\"bbn95\">Next</h3><p>Flame has been growing steadily in the Flutter community and many exciting things are coming up in the recent updates. Check out the <u><a href=\"https://github.com/flame-engine/awesome-flame#articles--tutorials\" target=\"_blank\" rel=\"noopener noreferrer\">Awesome Flame</a></u> repository for some amazing examples built with Flame.😋</p><p>Flame will continue to grow and allow us to build cool games with Flutter. We at Pieces are really excited about it. Stay tuned for our upcoming articles where we’ll explore Flame to build amazing games! 🎮</p>\n\n    <figure data-rt-type=\"video\" data-rt-align=\"center\">\n        <!-- strchf script -->\n<script>\n        if(window.strchfSettings === undefined) window.strchfSettings = {};\n    window.strchfSettings.stats = {url: \"https://pieces-app.storychief.io/en/flutter-game-pong-game-flame?id=2030726091&type=26\",title: \"Flutter Game: Build a Pong Game with Flutter Flame\",id: \"f48cd0d8-d254-4e17-a18e-3d20939412eb\"};\n            (function(d, s, id) {\n      var js, sjs = d.getElementsByTagName(s)[0];\n      if (d.getElementById(id)) {window.strchf.update(); return;}\n      js = d.createElement(s); js.id = id;\n      js.src = \"https://d37oebn0w9ir6a.cloudfront.net/scripts/v0/strchf.js\";\n      js.async = true;\n      sjs.parentNode.insertBefore(js, sjs);\n    }(document, 'script', 'storychief-jssdk'))\n    </script>\n<!-- End strchf script -->    </figure>\n",
  "Date": "Wed Sep 21 2022 15:25:53 GMT+0000 (Coordinated Universal Time)",
  "Author": "Rutvik Tak",
  "Author Photo": "https://uploads-ssl.webflow.com/6143afec68f555387049efb3/632b2cfe2e460d670e3f4926_rutviktak_cc8480396057da27bc161b244b354a24_1000.jpeg",
  "AMP URL": "",
  "TOC based on...": "h2,h3",
  "Tags": "flutter-9; flame",
  "CTA": "",
  "CTA link": "",
  "Canonical URL": ""
}
